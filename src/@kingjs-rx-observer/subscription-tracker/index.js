var { assert,
  '@kingjs': {
    IObserver: { Subscribed, Next, Complete, Error },
    '-rx-observer': { Proxy },
  }
} = module[require('@kingjs-module/dependencies')]()

function Noop() { }

/**
 * @description Given an observer, `SubscriptionTracker` raises its
 * `Subscribed` event supplying a master cancellation function that will cancel
 * many tracked observables. To track an observable, subscribe to it
 * with an observer created via `SubscriptionTracker.track`. Such an observer is
 * a proxy to the observer used to create the `SubscriptionTracker`. These proxies 
 * forward calls to `Next`, `Complete`, and `Error` but calls to `Subscribed` are not 
 * forwarded. Instead the `cancel` function supplied by `Subscribed` is captured
 * by `SubscriptionTracker` and called by the master cancellation function.
 * 
 * So it is: many observables -> subscription tracker -> observer
 * 
 * @constructor 
 * @param observer The observer whose `Subscribed` event is managed by the tracker.
 * @param onCancel A callback that occurs if the subscription is canceled.
 * 
 * @member cancel The master cancellation function.
 * @member cancelled True only after the mater cancellation function is called.
 * 
 * @method track Create a proxy to the the observer that is spied on by the tracker.
 * @param actions A pojo of `Next`, `Compete`, and/or `Error` actions.
 * 
 * @remarks The `cancel` functions of tracked observables captured by proxies
 * generated by calls to `SubscriptionTracker.track` are released if the proxy 
 * observes `completed` or `error`. This is justified because at that point
 * the observable should not generate any more events so is essentially cancelled
 * and should be made eligible for garbage collection.
 */
class SubscriptionTracker {
  constructor(observer, onCancel = Noop) {
    this.observer = observer
    this.cancelled = false
    this.map = null
    this.cancel = () => {
      assert(!this.cancelled)
      this.cancelled = true
      onCancel()

      if (!this.map)
        return
      
      for (var cancel of this.map.values())
        cancel()
    }

    observer[Subscribed](this.cancel)
  }

  track(actions) {
    if (!this.map)
      this.map = new Map()

    return new SubscriptionTrackerProxy(
      this.map, 
      this.observer[Proxy](actions)
    )
  }
}

class SubscriptionTrackerProxy {
  constructor(map, observer) {
    this.map = map
    this.observer = observer
  }

  [Subscribed](cancel) {
    this.map.set(this, cancel)
  }
  [Next](value) { 
    this.observer[Next](value)
  }
  [Complete]() { 
    this.map.delete(this)
    this.observer[Complete]()
  }
  [Error](error) {
    this.map.delete(this)
    this.observer[Error](error)
  }
}

module.exports = SubscriptionTracker